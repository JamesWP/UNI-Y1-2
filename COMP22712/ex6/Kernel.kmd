KMD
00000000:             ; ;-----------------------------------------------------------------------------;
00000000:             ; ;---                 LAB KERNEL V1.0                                       ---;
00000000:             ; ;---                 ---------------                                       ---;
00000000:             ; ;--- Author: James W Peach                                                 ---;
00000000:             ; ;-----------------------------------------------------------------------------;
00000000:             ; 
00000000:             ; ;---------------
00000000:             ; ;---  EXCEPTION VECTOR TABLE
00000000: EA000006    ;       B     vReset
00000004: EA000016    ;       B     vUndef
00000008: EA000016    ;       B     vSupervisor    
0000000C: EA0000D0    ;       B     vPreAbort
00000010: EA0000D0    ;       B     vDataAbort
00000014: EAFFFFFE    ;       B     .           ; unused vector
00000018: EA0000CF    ;       B     vIRQ        ; interrupt request
0000001C: EA0000CF    ;       B     vFIQ        ; fast interrupt request
00000020:             ; ;---------------
00000020:             ; 
00000020:             ; ;---------------
00000020:             ; ;- KERNEL MODE LITERALS
00000020:             ; SPSR_SYSMODENI  EQU  0xDF
00000020:             ; SPSR_SVCMODENI  EQU  0xD3
00000020:             ; SPSR_IRQMODENI  EQU  0xD2
00000020:             ; SPSR_USER       EQU  0b0101_0000 ; interupt enabled fast interupts disabled ARM
00000020:             ; ;---------------
00000020:             ; 
00000020:             ; ;---------------
00000020:             ; ;-    deals with resets and initialises kernel and then calls user code @main
00000020:             ; vReset
00000020:             ;       ;- initialise supervisor mode stack
00000020: E28FDD8D    ;       ADRL  SP,  sSVC
00000024: E28DD000    ; 
00000028:             ; 
00000028:             ;       ;- switch to system mode
00000028: E3A0E0DF    ;       MOV   LR, #(SPSR_SYSMODENI)     ; system mode no interrupts
0000002C: E121F00E    ;       MSR   CPSR_c, LR
00000030:             ;       ;- initialise user mode stack
00000030: E28FDE33    ;       ADRL  SP,  sUSR
00000034: E28DDA01    ; 
00000038:             ; 
00000038:             ;       ;- switch to intterupt mode
00000038: E3A0E0D2    ;       MOV   LR, #(SPSR_IRQMODENI)     ; int mode no interrupts
0000003C: E121F00E    ;       MSR   CPSR_c, LR
00000040:             ;       ;- initialise int mode stack
00000040: E28FDE32    ;       ADRL  SP,  sIRQ
00000044: E28DDA05    ; 
00000048:             ; 
00000048:             ;       ;- switch back to supervisor mode to:
00000048:             ;       ;- - do perhip Initialise
00000048:             ;       ;- - do user context switch with SPSR
00000048:             ; 
00000048: E3A0E0D3    ;       MOV   LR, #(SPSR_SVCMODENI)     ; supervisor mode no interrupts
0000004C: E121F00E    ;       MSR   CPSR_c, LR
00000050:             ; 
00000050:             ;       ;- initialise perhiperals
00000050: EB0000B8    ;       BL    PeripheralInitialise
00000054:             ; 
00000054:             ;       ;- switch to user mode using the SPSR
00000054: E3A0E050    ;       MOV   LR, #(SPSR_USER)
00000058: E161F00E    ;       MSR   SPSR_c, LR
0000005C:             ; 
0000005C:             ;       ;- call user code
0000005C: E28FEC03    ;       ADRL  LR,  Main
00000060: E1B0F00E    ;       MOVS  PC,  LR
00000064:             ; ;---------------
00000064:             ;       
00000064:             ; ;---------------    
00000064:             ; ;-    deals with undefined instructions
00000064:             ; vUndef
00000064: EAFFFFFE    ;       B   .
00000068:             ; ;---------------
00000068:             ;       
00000068:             ; ;---------------    
00000068:             ; ;-    deals with supervisor calls
00000068:             ; SVC_OP_MASK EQU 0xFF000000
00000068:             ; vSupervisor
00000068: E92D5800    ;       PUSH  {LR,r12,r11}
0000006C:             ; 
0000006C:             ;       ; save spsr incase nested SVC calls
0000006C: E14FB000    ;       MRS   r11, SPSR ;save spsr in reg
00000070: E92D0800    ;       PUSH  {r11}
00000074:             ; 
00000074: E51EC004    ;       LDR   r12, [LR, #-4]  ; load actual SVC instruction
00000078: E3CCC4FF    ;       BIC   r12,  r12,  #(SVC_OP_MASK) ; mask off opcode
0000007C:             ;       ; supervisor call 
0000007C: E35C0006    ;       CMP   r12, #SVCMax
00000080: 8A000016    ;       BHI   SVCUnknown
00000084:             ; 
00000084: E28FB010    ;       ADR   r11, SVCRoutines
00000088: E79BF10C    ;       LDR   PC, [r11,r12 LSL #2]
0000008C:             ; 
0000008C:             ; vSupervisor_return
0000008C:             ;       ; return to user code
0000008C:             ; 
0000008C:             ;       ; return saved value of saved flags
0000008C: E8BD0800    ;       POP   {r11}; containing saved spsr
00000090: E16FF00B    ;       MSR   SPSR, r11
00000094:             ; 
00000094: E8BD5800    ;       POP   {LR,r12,r11}
00000098: E1B0F00E    ;       MOVS  PC, LR ; return to user code here
0000009C:             ; 
0000009C:             ; ;-- this include should define symbols:
0000009C:             ; ;--                                    SVCRoutines   ; a table of routines
0000009C:             ; ;--                                                  ; each should return to: 
0000009C:             ; ;--                                                  ; vSupervisor_return
0000009C:             ; ;--                                    SVCMax        ; the max number of opcode
0000009C:             ; ;--                                    SVCUnknown    ; report the error proc
0000009C:             ; GET   KernelSVC.s
0000009C:             ; ;-----------------------------------------------------------------------------;
0000009C:             ; ;---                 LAB KERNEL V1.0                                       ---;
0000009C:             ; ;---                 ---------------                                       ---;
0000009C:             ; ;---                 SVC calls                                             ---;
0000009C:             ; ;--- Author: James W Peach                                                 ---;
0000009C:             ; ;-----------------------------------------------------------------------------;
0000009C:             ; 
0000009C:             ; ;-- this include should define symbols:
0000009C:             ; ;--                                    SVCRoutines   ; a table of routines
0000009C:             ; ;--                                                  ; each should return to: 
0000009C:             ; ;--                                                  ; vSupervisor_return
0000009C:             ; ;--                                    SVCMax        ; the max number of opcode
0000009C:             ; ;--                                    SVCUnknown    ; report the error proc
0000009C:             ; 
0000009C:             ; SVCRoutines
0000009C: 000000B4    ;       DEFW SVCRoutine0
000000A0: 000000B8    ;       DEFW SVCRoutine1
000000A4: 000000C0    ;       DEFW SVCRoutine2
000000A8: 000000C8    ;       DEFW SVCRoutine3
000000AC: 000000D0    ;       DEFW SVCRoutine4
000000B0: 000000D8    ;       DEFW SVCRoutine5
000000B4:             ; SVCRoutines_END
000000B4:             ; 
000000B4:             ; SVCMax EQU (SVCRoutines_END - SVCRoutines)/4
000000B4:             ; 
000000B4:             ; ;-- Routines
000000B4:             ; 
000000B4:             ; 
000000B4:             ; SVC_HALT  EQU  0
000000B4:             ; SVCRoutine0 
000000B4: EAFFFFFE    ;       B    .                                         ; user program end     
000000B8:             ; 
000000B8:             ; SVC_CHAR  EQU  1
000000B8:             ; SVCRoutine1                                          ; print char r0 is char
000000B8:             ;       ;procedure PrintChar(R0=char)
000000B8: EB00000F    ;       BL    PrintChar
000000BC: EAFFFFF2    ;       B     vSupervisor_return                        
000000C0:             ; 
000000C0:             ; SVC_STR   EQU  2
000000C0:             ; SVCRoutine2                                          ; print string r0 is
000000C0: EB00001E    ;       BL    PrintString                              ; string pointer
000000C4: EAFFFFF0    ;       B     vSupervisor_return                       
000000C8:             ; 
000000C8:             ; 
000000C8:             ; SVC_TIME  EQU  3
000000C8:             ; SVCRoutine3                                          ; get curent timer value
000000C8: EB000005    ;       BL    GetTimer                                 ; into r0
000000CC: EAFFFFEE    ;       B     vSupervisor_return
000000D0:             ; 
000000D0:             ; SVC_CLER  EQU  4
000000D0:             ; SVCRoutine4                                          ; get curent timer value
000000D0: EB00003F    ;       BL    ClearScreen                              ; into r0
000000D4: EAFFFFEC    ;       B     vSupervisor_return
000000D8:             ; 
000000D8:             ; SVC_BUTT  EQU  5
000000D8:             ; SVCRoutine5                                          ; get curent timer value
000000D8: EB000062    ;       BL    GetButton                                ; into r0
000000DC: EAFFFFEA    ;       B     vSupervisor_return
000000E0:             ; 
000000E0:             ; SVCUnknown
000000E0: EAFFFFFE    ;       B     .                                        ; unknown SVC call, hang..
000000E4:             ; 
000000E4:             ; ;-- this include should define symbols :
000000E4:             ; ;--                                      GetTimer    ; a procedure to return 
000000E4:             ; ;--                                                  ; curent timer value in r0 
000000E4:             ; GET   KernelTimer.s
000000E4:             ; ;-----------------------------------------------------------------------------;
000000E4:             ; ;---                 LAB KERNEL V1.0                                       ---;
000000E4:             ; ;---                 ---------------                                       ---;
000000E4:             ; ;---                 Timer                                                 ---;
000000E4:             ; ;--- Author: James W Peach                                                 ---;
000000E4:             ; ;-----------------------------------------------------------------------------;
000000E4:             ; 
000000E4:             ; ;-- this include should define symbols :
000000E4:             ; ;--                                      GetTimer    ; a procedure to return 
000000E4:             ; ;--                                                  ; curent timer value in r0 
000000E4:             ; 
000000E4:             ; TimerMemLoc   EQU   0x10000008
000000E4:             ; GetTimer
000000E4: E28F0FC7    ;         ADRL  r0, TimerMemLoc
000000E8: E2800BFF    ; 
000000EC: E28007FF    ; 
000000F0: E2800303    ; 
000000F4: E5500000    ;         LDRB  r0, [r0]
000000F8: E1A0F00E    ;         MOV   PC, LR
000000FC:             ; 
000000FC:             ; 
000000FC:             ; ;-- this include defines procedures to interface the KernelLCD
000000FC:             ; GET   KernelLCD.s
000000FC:             ; ;------------------------------------------------------------------------
000000FC:             ; ;            IO Library
000000FC:             ; ;           JWP 2015 - COMP227
000000FC:             ; ;           VERSION 1.1 for use in kernal
000000FC:             ; ;
000000FC:             ; ; contains io utilities
000000FC:             ; ;  incl write string, char, clear screen, convert control char to op
000000FC:             ; ;
000000FC:             ; ; Last modified 28/Jan, 04/Feb
000000FC:             ; ;
000000FC:             ; ;
000000FC:             ; ; Known bugs: None
000000FC:             ; ;
000000FC:             ; ;------------------------------------------------------------------------
000000FC:             ; 
000000FC:             ; 
000000FC:             ; LCD_Data      EQU 0x10000000
000000FC:             ; LCD_Control_O EQU 0x4
000000FC:             ; 
000000FC:             ; ENABLE  EQU   0x01
000000FC:             ; REGSEL  EQU   0x02
000000FC:             ; READNW  EQU   0x04
000000FC:             ;               
000000FC:             ; BACKLIGHT  EQU   0x20
000000FC:             ; CONTROL_CHAR EQU 0x20
000000FC:             ; CLEAR   EQU   0x01
000000FC:             ; 
000000FC:             ; ;---------------------------
000000FC:             ; ;procedure PrintChar(R0=char)
000000FC:             ; ; prints a single char on the LCD
000000FC:             ; ;---------------------------
000000FC:             ; PrintChar
000000FC: E92D4102    ;         PUSH{LR,r1,r8}
00000100:             ;         ;load Bdata and control pointers        
00000100: E3A08201    ;         MOV   r8, #LCD_Data
00000104:             ;         ; wait for device
00000104: EB000041    ;         BL    IOWait
00000108:             ; 
00000108:             ;         ; load control reg
00000108: E5981004    ;         LDR   r1, [r8, #LCD_Control_O]
0000010C:             ;         ; setup = set write set REGSEL unset READNW
0000010C: E3C11004    ;         BIC   r1, r1, #(READNW)
00000110:             ; 
00000110: E3500020    ;         CMP   r0, #CONTROL_CHAR
00000114:             ; 
00000114: A3811002    ;         ORRGE r1, r1, #(REGSEL) ; for data reg
00000118: B3C11002    ;         BICLT r1, r1, #(REGSEL) ; for control reg
0000011C: BB000018    ;         BLLT  ConvertControlChar; convert control char to operation
00000120:             ;         
00000120: E5881004    ;         STR   r1, [r8, #LCD_Control_O]
00000124:             ; 
00000124:             ;         ; set data
00000124: E5080000    ;         STR   r0, [r8]
00000128:             ; 
00000128:             ;         ; strobe enable
00000128: E3811001    ;         ORR   r1, r1, #(ENABLE)
0000012C: E5881004    ;         STR   r1, [r8, #LCD_Control_O]
00000130:             ; 
00000130:             ;         ; strobe off        
00000130: E3C11001    ;         BIC   r1, r1, #(ENABLE)
00000134: E5881004    ;         STR   r1, [r8, #LCD_Control_O]
00000138:             ; 
00000138:             ;         ;print char
00000138: E8BD4102    ;         POP{LR,r1,r8}
0000013C: E1A0F00E    ;         MOV   PC,LR
00000140:             ; ;---------------------------
00000140:             ; 
00000140:             ; ;---------------------------
00000140:             ; ;procedure PrintString(R0=string-pointer)
00000140:             ; ; prints a \0 terminated string pointed to by string-pointer
00000140:             ; ;---------------------------
00000140:             ; PrintString
00000140: E92D4002    ;         PUSH{LR,r1}
00000144: E1A01000    ;         MOV   r1, r0
00000148:             ; PrintString_repeat
00000148: E4D10001    ;         LDRB  r0, [r1], #1     ;load char + post increment
0000014C:             ;         ;check for termination char -> jump to end
0000014C: E3500000    ;         CMP   r0,#0
00000150:             ; 
00000150: 0A000001    ;         BEQ PrintString_end
00000154: EBFFFFE8    ;         BL PrintChar           ; PrintChar(R0=curent-char)
00000158: EAFFFFFA    ;         B  PrintString_repeat
0000015C:             ; PrintString_end
0000015C: E8BD4002    ;         POP{LR,r1}
00000160: E1A0F00E    ;         MOV   PC,LR
00000164:             ; ;---------------------------
00000164:             ; 
00000164:             ; EnableBacklight
00000164: E92D4101    ;         PUSH{LR,r0,r8}
00000168:             ;         
00000168:             ;         ;load Bdata and control pointers        
00000168: E3A08201    ;         MOV   r8, #LCD_Data    
0000016C:             ;  
0000016C:             ;         ; wait for io to be ready 
0000016C: EB000027    ;         BL    IOWait
00000170:             ;         
00000170: E5980004    ;         LDR   r0, [r8, #LCD_Control_O]
00000174: E3800020    ;         ORR   r0, r0, #(BACKLIGHT)
00000178: E5880004    ;         STR   r0, [r8, #LCD_Control_O]
0000017C:             ; 
0000017C: E8BD4101    ;         POP{LR,r0,r8}
00000180: E1A0F00E    ;         MOV   PC,LR
00000184:             ;       
00000184:             ; ;---------------------------
00000184:             ; ;procedure ConvertControlChar(r0=char OUTPUT)
00000184:             ; ; converts the char in r0 to an operation
00000184:             ; ;
00000184:             ; CURSOR_POS_MASK EQU 0x7F
00000184:             ; 
00000184:             ; MOVE_CUR_OFFSET EQU 0x80
00000184:             ; LINE      EQU 0x40
00000184:             ; BEGIN_LINE_CLEAR EQU 0x1F
00000184:             ; 
00000184:             ; LINE_FEED EQU 0x0A
00000184:             ; CARR_RET  EQU 0x0D
00000184:             ; ;---------------------------
00000184:             ; ConvertControlChar
00000184: E92D4006    ;         PUSH{LR,r1,r2}
00000188:             ;       
00000188: EB000020    ;         BL    IOWait    ; wait for io to be ready to read
0000018C: E1A02000    ;         MOV   r2, r0
00000190:             ; 
00000190:             ;         ; load curent control
00000190: E5980004    ;         LDR   r0, [r8, #LCD_Control_O]
00000194:             ;         ; set read&control, unset enable
00000194: E3800004    ;         ORR   r0, r0, #(READNW)
00000198: E3C00003    ;         BIC   r0, r0, #(ENABLE | REGSEL)
0000019C: E5880004    ;         STR   r0, [r8, #LCD_Control_O]      
000001A0:             ;         ; enable bus too
000001A0: E3800001    ;         ORR   r0, r0, #(ENABLE)
000001A4: E5880004    ;         STR   r0, [r8, #LCD_Control_O]
000001A8:             ;         ; read data
000001A8: E5181000    ;         LDR   r1, [r8]      
000001AC:             ;         ; disable bus
000001AC: E3C00001    ;         BIC   r0, r0, #(ENABLE)
000001B0: E5880004    ;         STR   r0, [r8, #LCD_Control_O]
000001B4:             ; 
000001B4:             ;         ; mask data to get curent cursor position
000001B4: E201107F    ;         AND   r1, r1, #CURSOR_POS_MASK
000001B8:             ;  
000001B8:             ;         ; if line feed char then add line length to pos
000001B8: E352000A    ;         CMP   r2, #LINE_FEED
000001BC: 02810040    ;         ADDEQ r0, r1, #(LINE)
000001C0:             ;         
000001C0:             ;         ; if carrege return clear line pos bits XXXX0000 
000001C0: E352000D    ;         CMP   r2, #CARR_RET
000001C4: 03C1001F    ;         BICEQ r0, r1, #(BEGIN_LINE_CLEAR)        
000001C8:             ; 
000001C8:             ;         ; add command to position
000001C8: E2800080    ;         ADD   r0, r0, #(MOVE_CUR_OFFSET)
000001CC:             ; 
000001CC: E8BD4006    ;         POP{LR,r1,r2}
000001D0: E1A0F00E    ;         MOV PC,LR
000001D4:             ; ;---------------------------
000001D4:             ; 
000001D4:             ; ;---------------------------
000001D4:             ; ;procedure ClearScreen
000001D4:             ; ; clears the screen and places cursor in top left corner
000001D4:             ; ;---------------------------
000001D4:             ; ClearScreen
000001D4: E92D4301    ;         PUSH{LR,r0,r9,r8}
000001D8:             ;         ;load data and control pointers        
000001D8: E3A08201    ;         MOV   r8, #LCD_Data
000001DC:             ;         ;wait for device
000001DC: EB00000B    ;         BL    IOWait
000001E0:             ;         ;clear screen
000001E0:             ;         
000001E0: E5980004    ;         LDR   r0, [r8, #LCD_Control_O]
000001E4:             ;         ; set control
000001E4: E3C00006    ;         BIC   r0, r0, #(READNW | REGSEL)
000001E8: E5880004    ;         STR   r0, [r8, #LCD_Control_O]
000001EC:             ;         ; set data
000001EC: E3A00001    ;         MOV   r0, #CLEAR
000001F0: E5080000    ;         STR   r0, [r8]
000001F4:             ;         
000001F4:             ;         ; strobe enable on
000001F4: E5980004    ;         LDR   r0, [r8, #LCD_Control_O]
000001F8: E3800001    ;         ORR   r0, r0, #(ENABLE)
000001FC: E5880004    ;         STR   r0, [r8, #LCD_Control_O]
00000200:             ; 
00000200:             ;         ; strobe enable off
00000200: E3C00001    ;         BIC   r0, r0, #(ENABLE)
00000204: E5880004    ;         STR   r0, [r8, #LCD_Control_O]
00000208:             ; 
00000208: E8BD4301    ;         POP{LR,r0,r9,r8}
0000020C: E1A0F00E    ;         MOV   PC,LR
00000210:             ; ;---------------------------
00000210:             ; 
00000210:             ; ;---------------------------
00000210:             ; ;procedure IOWait
00000210:             ; ; waits for the io to be ready
00000210:             ; ;---------------------------
00000210:             ; IOWait
00000210: E92D0003    ;         PUSH{r0,r1}
00000214:             ; 
00000214:             ; IOWait_repeat
00000214:             ; 
00000214:             ;         ; load curent control
00000214: E5980004    ;         LDR   r0, [r8, #LCD_Control_O]
00000218:             ; 
00000218:             ;         ; set read&control, unset enable
00000218: E3800004    ;         ORR   r0, r0, #(READNW)
0000021C: E3C00003    ;         BIC   r0, r0, #(ENABLE | REGSEL)
00000220: E5880004    ;         STR   r0, [r8, #LCD_Control_O]
00000224:             ;         
00000224:             ;         ; enable bus too
00000224: E3800001    ;         ORR   r0, r0, #(ENABLE)
00000228: E5880004    ;         STR   r0, [r8, #LCD_Control_O]
0000022C:             ;     
0000022C:             ;         ; read data
0000022C: E5181000    ;         LDR   r1, [r8]      
00000230:             ;             
00000230:             ;         ; disable bus
00000230: E3C00001    ;         BIC   r0, r0, #(ENABLE)
00000234: E5880004    ;         STR   r0, [r8, #LCD_Control_O]
00000238:             ; 
00000238:             ;         ; test bit 7 is low else repeat
00000238: E2111080    ;         ANDS  r1, r1, #0x80
0000023C: 1AFFFFF4    ;         BNE   IOWait_repeat
00000240:             ; 
00000240: E8BD0003    ;         POP{r0,r1}
00000244: E1A0F00E    ;         MOV   PC,LR
00000248:             ; 
00000248:             ; ;--------------------------
00000248:             ; ;procedure LCDInit
00000248:             ; ; initialises control signals
00000248:             ; ;--------------------------
00000248:             ; LCDInit
00000248: E92D0101    ;         PUSH{r0,r8}
0000024C: E3A08201    ;         MOV   r8, #LCD_Data
00000250:             ; 
00000250: E3A00000    ;         MOV   r0, #0
00000254: E5080000    ;         STR   r0, [r8] ; init data
00000258: E3A00010    ;         MOV   r0, #0x00000010
0000025C: E5880004    ;         STR   r0, [r8, #LCD_Control_O] ; init control
00000260:             ; 
00000260: E8BD0101    ;         POP{r0,r8}
00000264: E1A0F00E    ;         MOV   PC, LR
00000268:             ; ;--------------------------
00000268:             ; 
00000268:             ; ;-- this include defines procedures to interface the buttons
00000268:             ; GET   KernelButtons.s
00000268:             ; ;-----------------------------------------------------------------------------;
00000268:             ; ;---                 LAB KERNEL V1.0                                       ---;
00000268:             ; ;---                 ---------------                                       ---;
00000268:             ; ;---                 Button io                                             ---;
00000268:             ; ;--- Author: James W Peach                                                 ---;
00000268:             ; ;-----------------------------------------------------------------------------;
00000268:             ; ;-- this include defines procedures to interface the buttons
00000268:             ; 
00000268:             ; 
00000268:             ; ButtonsMem EQU 0x10000004
00000268:             ; ButtonsMask EQU 0x3
00000268:             ; ButtonsShift EQU 0x6
00000268:             ; 
00000268:             ; GetButton
00000268:             ;       ;load
00000268: E28F0F65    ;       ADRL  r0, ButtonsMem
0000026C: E2800BFF    ; 
00000270: E28007FF    ; 
00000274: E2800303    ; 
00000278: E5500000    ;       LDRB  r0, [r0]
0000027C: E1A00320    ;       MOV   r0, r0, LSR #ButtonsShift
00000280: E2000003    ;       AND   r0, r0, #ButtonsMask
00000284: E1A0F00E    ;       MOV PC,LR
00000288:             ;       
00000288:             ; 
00000288:             ; ;-- this include defines procedures to handle interrupts:
00000288:             ; ;--                                  InitialiseInterrupts : inits interrupts
00000288:             ; ;--                                  InterruptHandler     : handles interupt
00000288:             ; GET   KernelInt.s
00000288:             ; ;-----------------------------------------------------------------------------;
00000288:             ; ;---                 LAB KERNEL V1.0                                       ---;
00000288:             ; ;---                 ---------------                                       ---;
00000288:             ; ;---                 Button io                                             ---;
00000288:             ; ;--- Author: James W Peach                                                 ---;
00000288:             ; ;-----------------------------------------------------------------------------;
00000288:             ; ;-- this include defines procedures to handle interrupts:
00000288:             ; ;--                                  InitialiseInterrupts : inits interrupts
00000288:             ; ;--                                  InterruptHandler     : handles interupt
00000288:             ; 
00000288:             ; ;-- LITERALS
00000288:             ; TIMER_COMP_BYTE   EQU   0x1000_000C        ; timer compare mem loc
00000288:             ; INTERUPT_BITS_O   EQU   0xC               ; interrupt flags offset
00000288:             ; INTERUPT_ENABLE_O EQU   0x10              ; interrupt enable offset
00000288:             ; TIMER_ENABLE_BIT  EQU   0b0000_0001        ; CPSR timer enable bit
00000288:             ; 
00000288:             ; TIMER_DELAY       EQU   5
00000288:             ; TIMER_MAX         EQU   0xFF
00000288:             ; 
00000288:             ; INTTERUPT_TIMER_MASK EQU 0b0000_0001
00000288:             ; 
00000288:             ; ;-- VARIABLES
00000288: 00000000    ; TIMER_CURENT_VALUE      DEFW  0 
0000028C:             ; 
0000028C:             ; ;-------------------------
0000028C:             ; ;-- procedure  InitialiseInterrupts
0000028C:             ; ;-- 
0000028C:             ; ;-- initialises hardware interrupts
0000028C:             ; ;-- sets timer interrupt to interrupt @100ms 
0000028C:             ; InitialiseInterrupts
0000028C: E92D4003    ;       PUSH {r0,r1,LR}
00000290:             ; 
00000290: E28F1F5D    ;       ADRL  r1, TIMER_COMP_BYTE
00000294: E2811BFF    ; 
00000298: E28117FF    ; 
0000029C: E2811303    ; 
000002A0: EBFFFF8F    ;       BL    GetTimer
000002A4:             ;       ; set timer interrupt to be NOW+@100ms
000002A4: E2800005    ;       ADD   r0, r0, #TIMER_DELAY
000002A8: E5010000    ;       STR   r0, [r1]
000002AC:             ; 
000002AC:             ;       ; disable all interrupts except timer
000002AC: E3A00001    ;       MOV   r0, #(TIMER_ENABLE_BIT)
000002B0: E5810010    ;       STR   r0, [r1, #INTERUPT_ENABLE_O]
000002B4:             ; 
000002B4: E8BD4003    ;       POP  {r0,r1,LR}
000002B8: E1A0F00E    ;       MOV   PC, LR
000002BC:             ; 
000002BC:             ; ; called when an interrupt happens
000002BC:             ; ; should pass to each handler in turn to decide who should process event
000002BC:             ; InterruptHandler
000002BC:             ;       ; load interrupt port into r0
000002BC: E92D4001    ;       PUSH {LR,r0}
000002C0: E28F0F51    ;       ADRL r0, TIMER_COMP_BYTE
000002C4: E2800BFF    ; 
000002C8: E28007FF    ; 
000002CC: E2800303    ; 
000002D0: E5D0000C    ;       LDRB r0, [r0, #INTERUPT_BITS_O]
000002D4:             ;       ; work out what was triggered interupt
000002D4:             ; 
000002D4:             ;       ; BL list of handlers
000002D4: EB000001    ;       BL    InterruptTimer    ; handle timer intterupt if triggered
000002D8:             ; 
000002D8:             ; ; called at the end of the list of handlers if none found or
000002D8:             ; ; jumped to if a handler successfully completes
000002D8:             ; InterruptComplete
000002D8:             ;       ; exit handler
000002D8: E8BD4001    ;       POP {LR,r0}
000002DC: E25EF004    ;       SUBS  PC, LR, #4
000002E0:             ; 
000002E0:             ; InterruptTimer
000002E0:             ;       ; test r0 for timer flags
000002E0: E3100001    ;       TST   r0, #(INTTERUPT_TIMER_MASK)
000002E4: 01A0F00E    ;       MOVEQ PC, LR                              ; if no flag return
000002E8:             ;       ; else do timer stuff
000002E8: E92D4002    ;       PUSH{LR,r1}
000002EC:             ; 
000002EC:             ;       ; load offset point
000002EC: E28F1F46    ;       ADRL r1, TIMER_COMP_BYTE
000002F0: E2811BFF    ; 
000002F4: E28117FF    ; 
000002F8: E2811303    ; 
000002FC:             ; 
000002FC:             ;       ;clear interrupt bit
000002FC: E3C00001    ;       BIC  r0, r0, #(INTTERUPT_TIMER_MASK)
00000300: E5C1000C    ;       STRB r0, [r1, #INTERUPT_BITS_O]
00000304:             ; 
00000304:             ;       ; store incrament in timer
00000304: E51F0084    ;       LDR   r0, TIMER_CURENT_VALUE
00000308: E2800001    ;       ADD   r0, r0, #1
0000030C: E50F008C    ;       STR   r0, TIMER_CURENT_VALUE
00000310:             ; 
00000310:             ;       ; set next timer point
00000310: EBFFFF73    ;       BL    GetTimer
00000314: E2800005    ;       ADD   r0, r0, #TIMER_DELAY
00000318:             ;       ; if timer is too large subtract MAX
00000318: E35000FF    ;       CMP   r0, #TIMER_MAX
0000031C: 824000FF    ;       SUBHI r0, r0, #TIMER_MAX
00000320:             ;       ; wrap timer compare value
00000320: E5010000    ;       STR   r0, [r1]
00000324:             ; 
00000324: EB000002    ;       BL    KeyboardScan
00000328:             ; 
00000328:             ;       ; return
00000328: E8BD4002    ;       POP{LR,r1}
0000032C: EAFFFFE9    ;       B     InterruptComplete
00000330:             ; 
00000330:             ; ;-- this include defines procedures to handle keyboard scanning:
00000330:             ; ;--                                  KeyboardScan         : called periodically
00000330:             ; ;--                                                       : to handle key read
00000330:             ; GET   KernelKeyboard.s
00000330:             ; ;-----------------------------------------------------------------------------;
00000330:             ; ;---                 LAB KERNEL V1.0                                       ---;
00000330:             ; ;---                 ---------------                                       ---;
00000330:             ; ;---                 Button io                                             ---;
00000330:             ; ;--- Author: James W Peach                                                 ---;
00000330:             ; ;-----------------------------------------------------------------------------;
00000330:             ; 
00000330:             ; ;-- this include defines procedures to handle keyboard scanning:
00000330:             ; ;--                                  KeyboardScan         : called periodically
00000330:             ; ;--                                                       : to handle key read
00000330:             ; 
00000330: 00000000    ; LAST_KEY_PRESSED    DEFW    0x0
00000334:             ; 
00000334:             ; ;-- LITERALS
00000334:             ; 
00000334:             ; ;--- KEYMAP
00000334:             ; KEY_3   EQU   0
00000334:             ; KEY_6   EQU   1
00000334:             ; KEY_9   EQU   2
00000334:             ; KEY_H   EQU   3
00000334:             ; 
00000334:             ; KEY_2   EQU   4
00000334:             ; KEY_5   EQU   5
00000334:             ; KEY_8   EQU   6
00000334:             ; KEY_0   EQU   7
00000334:             ; 
00000334:             ; KEY_1   EQU   8
00000334:             ; KEY_4   EQU   9
00000334:             ; KEY_7   EQU   10
00000334:             ; KEY_S   EQU   11
00000334:             ; 
00000334:             ; 
00000334:             ; ;---------------------
00000334:             ; ;--procedure KeyboardScan
00000334:             ; ;-- scans the keys for presses and updates LAST_KEY_PRESSED
00000334:             ; ;-
00000334:             ; ;- puudeocode
00000334:             ; ;-
00000334:             ; ;-  SCAN
00000334:             ; ;---  SCAN LINE 1
00000334:             ; ;-----  
00000334:             ; ;---  SCAN LINE 2
00000334:             ; ;---  SCAN LINE 3
00000334:             ; ;-
00000334:             ; ;-  IF KEY IS PRESSED 
00000334:             ; ;---  UPDATE #LAST_KEY_PRESSED
00000334:             ; ;---------------------
00000334:             ; KeyboardScan
00000334: E1A0F00E    ;               MOV   PC, LR
00000338:             ; ;---------------------
00000338:             ; 
00000338:             ; ;---------------
00000338:             ; ;-- procedure PeripheralInitialise initialies perhiperals
00000338:             ; PeripheralInitialise
00000338: E92D4000    ;       PUSH  {LR}
0000033C: EBFFFFC1    ;       BL    LCDInit           ; init control signals
00000340: EBFFFF87    ;       BL    EnableBacklight   ; enable backlight
00000344: EBFFFFD0    ;       BL    InitialiseInterrupts; init interrupts
00000348: EBFFFFA1    ;       BL    ClearScreen       ; clear screen
0000034C: E8BD4000    ;       POP   {LR}
00000350: E1A0F00E    ;       MOV   PC, LR
00000354:             ; ;---------------
00000354:             ; 
00000354:             ; ;---------------    
00000354:             ; ;-    deals with prefetch aborts
00000354:             ; vPreAbort
00000354: EAFFFFFE    ;       B   .
00000358:             ; ;---------------
00000358:             ;       
00000358:             ; ;---------------    
00000358:             ; ;-    deals with data aborts
00000358:             ; vDataAbort
00000358: EAFFFFFE    ;       B   .
0000035C:             ; ;---------------
0000035C:             ;       
0000035C:             ; ;---------------    
0000035C:             ; ;-    deals with interrupt handling
0000035C:             ; vIRQ  
0000035C: EAFFFFD6    ;       B   InterruptHandler
00000360:             ; ;---------------
00000360:             ;       
00000360:             ; ;---------------    
00000360:             ; ;-    deals with fast interrupt handling
00000360:             ; vFIQ
00000360: EAFFFFFE    ;       B   .
00000364:             ; ;---------------
00000364:             ;      
00000364:             ; 
00000364:             ; GET   UserProgram.s
00000364:             ; ;-----------------------------------------------------------------------------;
00000364:             ; ;-----                    UserProgram Test                                ----;
00000364:             ; ;-----                    a program to test svc calls                     ----;
00000364:             ; ;--- Author: James W Peach                                                 ---;
00000364:             ; ;-----------------------------------------------------------------------------;
00000364:             ; 
00000364:             ; ;------------------------
00000364:             ; ;-- literals
00000364:             ; 
00000364:             ; ;------------------------
00000364:             ; ;-- variables memory
00000364:             ; 
00000364:             ; ;------------------------
00000364:             ; ;- UserProgram
00000364:             ; Main    
00000364: EAFFFFFE    ;         B     .
00000368:             ;  
00000368:             ; ;---------------
00000368:             ; ;-    stack areas
00000368:             ;       ALIGN
00000368:             ;       DEFS  4096
00001368:             ; sUSR  ; user mode stack area
00001368:             ;       DEFS  4096
00002368:             ; sSVC  ; svc mode stack area
00002368:             ;       DEFS  4096
00003368:             ; sABO  ; abort mode stack area
00003368:             ;       DEFS  4096
00004368:             ; sUDE  ; undefined mode stack area
00004368:             ;       DEFS  4096
00005368:             ; sIRQ  ; interrupt mode stack area
00005368:             ;       DEFS  4096
00006368:             ; sFIQ  ; fast interrupt mode stack area
00006368:             ; ;---------------
00006368:             ; 
00006368:             ; 
00006368:             ; ; FIN
00006368:             ; 

Symbol Table: Labels
: SPSR_SYSMODENI                    000000DF  Value
: SPSR_SVCMODENI                    000000D3  Value
: SPSR_IRQMODENI                    000000D2  Value
: SPSR_USER                         00000050  Value
: vReset                            00000020  Local -- ARM
: vUndef                            00000064  Local -- ARM
: SVC_OP_MASK                       FF000000  Value
: vSupervisor                       00000068  Local -- ARM
: vSupervisor_return                0000008C  Local -- ARM
: SVCRoutines                       0000009C  Local -- ARM
: SVCRoutines_END                   000000B4  Local -- ARM
: SVCMax                            00000006  Value
: SVC_HALT                          00000000  Value
: SVCRoutine0                       000000B4  Local -- ARM
: SVC_CHAR                          00000001  Value
: SVCRoutine1                       000000B8  Local -- ARM
: SVC_STR                           00000002  Value
: SVCRoutine2                       000000C0  Local -- ARM
: SVC_TIME                          00000003  Value
: SVCRoutine3                       000000C8  Local -- ARM
: SVC_CLER                          00000004  Value
: SVCRoutine4                       000000D0  Local -- ARM
: SVC_BUTT                          00000005  Value
: SVCRoutine5                       000000D8  Local -- ARM
: SVCUnknown                        000000E0  Local -- ARM
: TimerMemLoc                       10000008  Value
: GetTimer                          000000E4  Local -- ARM
: LCD_Data                          10000000  Value
: LCD_Control_O                     00000004  Value
: ENABLE                            00000001  Value
: REGSEL                            00000002  Value
: READNW                            00000004  Value
: BACKLIGHT                         00000020  Value
: CONTROL_CHAR                      00000020  Value
: CLEAR                             00000001  Value
: PrintChar                         000000FC  Local -- ARM
: PrintString                       00000140  Local -- ARM
: PrintString_repeat                00000148  Local -- ARM
: PrintString_end                   0000015C  Local -- ARM
: EnableBacklight                   00000164  Local -- ARM
: CURSOR_POS_MASK                   0000007F  Value
: MOVE_CUR_OFFSET                   00000080  Value
: LINE                              00000040  Value
: BEGIN_LINE_CLEAR                  0000001F  Value
: LINE_FEED                         0000000A  Value
: CARR_RET                          0000000D  Value
: ConvertControlChar                00000184  Local -- ARM
: ClearScreen                       000001D4  Local -- ARM
: IOWait                            00000210  Local -- ARM
: IOWait_repeat                     00000214  Local -- ARM
: LCDInit                           00000248  Local -- ARM
: ButtonsMem                        10000004  Value
: ButtonsMask                       00000003  Value
: ButtonsShift                      00000006  Value
: GetButton                         00000268  Local -- ARM
: TIMER_COMP_BYTE                   1000000C  Value
: INTERUPT_BITS_O                   0000000C  Value
: INTERUPT_ENABLE_O                 00000010  Value
: TIMER_ENABLE_BIT                  00000001  Value
: TIMER_DELAY                       00000005  Value
: TIMER_MAX                         000000FF  Value
: INTTERUPT_TIMER_MASK              00000001  Value
: TIMER_CURENT_VALUE                00000288  Local -- ARM
: InitialiseInterrupts              0000028C  Local -- ARM
: InterruptHandler                  000002BC  Local -- ARM
: InterruptComplete                 000002D8  Local -- ARM
: InterruptTimer                    000002E0  Local -- ARM
: LAST_KEY_PRESSED                  00000330  Local -- ARM
: KEY_3                             00000000  Value
: KEY_6                             00000001  Value
: KEY_9                             00000002  Value
: KEY_H                             00000003  Value
: KEY_2                             00000004  Value
: KEY_5                             00000005  Value
: KEY_8                             00000006  Value
: KEY_0                             00000007  Value
: KEY_1                             00000008  Value
: KEY_4                             00000009  Value
: KEY_7                             0000000A  Value
: KEY_S                             0000000B  Value
: KeyboardScan                      00000334  Local -- ARM
: PeripheralInitialise              00000338  Local -- ARM
: vPreAbort                         00000354  Local -- ARM
: vDataAbort                        00000358  Local -- ARM
: vIRQ                              0000035C  Local -- ARM
: vFIQ                              00000360  Local -- ARM
: Main                              00000364  Local -- ARM
: sUSR                              00001368  Local -- ARM
: sSVC                              00002368  Local -- ARM
: sABO                              00003368  Local -- ARM
: sUDE                              00004368  Local -- ARM
: sIRQ                              00005368  Local -- ARM
: sFIQ                              00006368  Local -- ARM
